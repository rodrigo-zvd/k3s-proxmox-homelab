# .gitlab-ci.yml
#
# Pipeline declarativa para construir o Homelab K3s do zero.
# Esta pipeline executa o "Padrão 1" (Bootstrap da Plataforma)
# para que o ArgoCD (Padrão 2) possa assumir os workloads.

stages:
  - build_infra
  - bootstrap_platform
  - seed_gitops

# --- Etapa 1: Provisionar VMs e K3s ---
build_infra:
  stage: build_infra
  image: ubuntu:22.04 # Usamos uma imagem base e instalamos o que precisamos
  
  before_script:
    - echo "Installing dependencies (Terraform, Ansible, SSH)..."
    - apt-get update
    - DEBIAN_FRONTEND=noninteractive apt-get install -y curl unzip git openssh-client python3 python3-pip sshpass
    - pip3 install ansible
    # Instala o Terraform
    - curl -o terraform.zip https://releases.hashicorp.com/terraform/1.9.1/terraform_1.9.1_linux_amd64.zip
    - unzip terraform.zip && mv terraform /usr/local/bin/
    - terraform --version
    
    # --- Configuração de Credenciais ---
    # Configura a chave SSH (do GitLab Variable $SSH_PRIVATE_KEY)
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    # Adiciona o host Proxmox ao known_hosts para evitar prompts
    - ssh-keyscan -H $PROXMOX_HOST_IP >> ~/.ssh/known_hosts

  script:
    - echo "Provisioning infrastructure with Terraform..."
    - cd terraform
    # Cria o arquivo de segredos do Terraform a partir das CI Variables
    - echo "proxmox_api_token_id = \"$PROXMOX_API_TOKEN_ID\"" > terraform.tfvars
    - echo "proxmox_api_token_secret = \"$PROXMOX_API_TOKEN_SECRET\"" >> terraform.tfvars
    - terraform init
    - terraform apply -auto-approve
    
    - echo "Waiting for VMs to boot..."
    - sleep 30 # Garante que o cloud-init e o SSH estejam prontos
    
    - echo "Installing K3s with Ansible..."
    - cd ../ansible
    - mkdir -p ../build # Cria a pasta para o Kubeconfig
    - ansible-playbook install-k3s.yml

  artifacts:
    # Salva o Kubeconfig para ser usado pela próxima etapa
    paths:
      - build/k3s-homelab.yaml
    when: on_success
  
  cache:
    # Armazena em cache o .tfstate para que o 'destroy' funcione
    key: ${CI_PROJECT_ID}-tfstate
    paths:
      - terraform/terraform.tfstate*
      - terraform/.terraform.lock.hcl

# --- Etapa 2: Instalar a Plataforma (MetalLB, Nginx, Argo) ---
bootstrap_platform:
  stage: bootstrap_platform
  image: bitnami/kubectl:latest # Imagem leve que já tem kubectl
  needs: [build_infra] # Depende da Etapa 1
  
  before_script:
    - echo "Installing Helm..."
    - "curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3"
    - chmod 700 get_helm.sh
    - ./get_helm.sh
    
    # Configura o Kubeconfig salvo da etapa anterior
    - export KUBECONFIG=$CI_PROJECT_DIR/build/k3s-homelab.yaml
    
    # Adiciona os repositórios Helm
    - helm repo add metallb https://metallb.github.io/metallb
    - helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
    - helm repo add argo https://argoproj.github.io/argo-helm
    - helm repo update

  script:
    - echo "Bootstrapping Platform (Padrão 1)..."
    
    # 1. Instala MetalLB (Helm + Config)
    - kubectl create namespace metallb-system || echo "ns metallb-system already exists"
    # Usamos 'helm upgrade --install' para idempotência
    - helm upgrade --install metallb metallb/metallb --namespace metallb-system
    - echo "Waiting for MetalLB Operator..."
    - kubectl wait --namespace metallb-system --for=condition=ready pod --selector=app.kubernetes.io/name=metallb --timeout=300s
    - kubectl apply -f helm-bootstrap/metallb-config.yml

    # 2. Instala Ingress-Nginx (Helm Declarativo)
    - kubectl create namespace ingress-nginx || echo "ns ingress-nginx already exists"
    - helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
        --namespace ingress-nginx \
        -f helm-bootstrap/nginx-values.yml
        
    # 3. Instala ArgoCD (Helm Declarativo)
    - kubectl create namespace argocd || echo "ns argocd already exists"
    - helm upgrade --install argocd argo/argo-cd \
        --namespace argocd \
        -f helm-bootstrap/argocd-values.yml

  after_script:
    # Apenas para verificação nos logs da pipeline
    - echo "Platform Bootstrap Complete. Verifying services..."
    - sleep 60 # Espera o MetalLB alocar os IPs
    - kubectl get svc -n ingress-nginx
    - kubectl get svc -n argocd

# --- Etapa 3: "Semear" o GitOps ---
seed_gitops:
  stage: seed_gitops
  image: bitnami/kubectl:latest
  needs: [bootstrap_platform] # Depende da Etapa 2
  
  before_script:
    - export KUBECONFIG=$CI_PROJECT_DIR/build/k3s-homelab.yaml
    
  script:
    - echo "Seeding GitOps with root workloads app..."
    # Aplica o manifesto "App-Pai" (root-workloads-app.yml)
    # que diz ao ArgoCD para gerenciar a pasta 'workloads/'
    - kubectl apply -f root-workloads-app.yml --validate=false

  after_script:
    - echo "GitOps Seeded. ArgoCD will now take over workloads."
    - sleep 120 # Espera o ArgoCD sincronizar o app hello-world
    - echo "Verifying hello-world app endpoint..."
    - curl http://hello.172.20.1.61.nip.io